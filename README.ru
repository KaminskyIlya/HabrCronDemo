Это эталонная реализация тестового задания, описанного в статье https://habr.com/ru/post/571342/ (см. ниже).
Здесь используется более продуктивный алгоритм, чем был предложен автором.
Технически возможно планировать даты с точностью до микросекунд.
Может послужить для вас отправной точкой для создания собственной производительной версии
подобного класса на любом удобном языке (см. пакет com.habr.cron.ilya).
Делалась в рамках написания соответствующей обзорной статьи.

Пакет *com.habr.cron.novar* - java-реализация исходного алгоритма NoVar (https://habr.com/users/NoVar)
	Алгоритм был предложен в оригинальной статье https://habr.com/ru/post/571342/

Пакет *com.habr.cron.ilya* (Example) - эталонная и хорошо проверенная реализация продуктивного алгоритма.
	Если вы хотите понять проект и базовый алгоритм, лучше начинать с изучения её.

Пакет *com.habr.cron.opt* (Optimized) - стабилизированная оптимизированная ветка.
    В этот пакет помещаются самые передовые оптимизированные варианты кода продуктивного алгоритма
    после соответствующих замеров производительности и после прохождения всех тестов.
    Именно из этой ветки код далее будет мигрировать в проект CronEx.

Пакет *com.habr.cron.dev* (Develop) - используется для отработки новых техник оптимизации.
	Может быть нестабилен или содержать ошибки. Используется для экспериментов.

Пакет com.habr.cron.speed содержит бенчмарки, для сравнения разных алгоритмов.


Исходная постановка задачи:
Сдалать планировщик задач с разрешающей сопособностью до миллисекунд.
Во вложение класс C#, который предлагается реализовать. Описание методов - в xml-комментах.
Обращаю Ваше внимание, что класс должен быть эффективным и не использовать много памяти и ресурсов даже тогда,
когда в расписании задано много значений. Например очень много значений с шагом в одну миллисекунду.

namespace Test
{

	/// <summary>
	/// Класс для задания и расчета времени по расписанию.
	/// </summary>
	public class Schedule
	{
		/// <summary>
		/// Создает пустой экземпляр, который будет соответствовать
		/// расписанию типа "*.*.* * *:*:*.*" (раз в 1 мс).
		/// </summary>
		public Schedule()
		{
		}

		/// <summary>
		/// Создает экземпляр из строки с представлением расписания.
		/// </summary>
		/// <param name="scheduleString">Строка расписания.
		/// Формат строки:
		///     yyyy.MM.dd w HH:mm:ss.fff
		///     yyyy.MM.dd HH:mm:ss.fff
		///     HH:mm:ss.fff
		///     yyyy.MM.dd w HH:mm:ss
		///     yyyy.MM.dd HH:mm:ss
		///     HH:mm:ss
		/// Где yyyy - год (2000-2100)
		///     MM - месяц (1-12)
		///     dd - число месяца (1-31 или 32). 32 означает последнее число месяца
		///     w - день недели (0-6). 0 - воскресенье, 6 - суббота
		///     HH - часы (0-23)
		///     mm - минуты (0-59)
		///     ss - секунды (0-59)
		///     fff - миллисекунды (0-999). Если не указаны, то 0
		/// Каждую часть даты/времени можно задавать в виде списков и диапазонов.
		/// Например:
		///     1,2,3-5,10-20/3
		///     означает список 1,2,3,4,5,10,13,16,19
		/// Дробью задается шаг в списке.
		/// Звездочка означает любое возможное значение.
		/// Например (для часов):
		///     */4
		///     означает 0,4,8,12,16,20
		/// Вместо списка чисел месяца можно указать 32. Это означает последнее
		/// число любого месяца.
		/// Пример:
		///     *.9.*/2 1-5 10:00:00.000
		///     означает 10:00 во все дни с пн. по пт. по нечетным числам в сентябре
		///     *:00:00
		///     означает начало любого часа
		///     *.*.01 01:30:00
		///     означает 01:30 по первым числам каждого месяца
		/// </param>
		public Schedule(string scheduleString)
		{
		}

		/// <summary>
		/// Возвращает следующий ближайший к заданному времени момент в расписании или
		/// само заданное время, если оно есть в расписании.
		/// </summary>
		/// <param name="t1">Заданное время</param>
		/// <returns>Ближайший момент времени в расписании</returns>
		public DateTime NearestEvent(DateTime t1)
		{
		}

		/// <summary>
		/// Возвращает предыдущий ближайший к заданному времени момент в расписании или
		/// само заданное время, если оно есть в расписании.
		/// </summary>
		/// <param name="t1">Заданное время</param>
		/// <returns>Ближайший момент времени в расписании</returns>
		public DateTime NearestPrevEvent(DateTime t1)
		{
		}

		/// <summary>
		/// Возвращает следующий момент времени в расписании.
		/// </summary>
		/// <param name="t1">Время, от которого нужно отступить</param>
		/// <returns>Следующий момент времени в расписании</returns>
		public DateTime NextEvent(DateTime t1)
		{
		}

		/// <summary>
		/// Возвращает предыдущий момент времени в расписании.
		/// </summary>
		/// <param name="t1">Время, от которого нужно отступить</param>
		/// <returns>Предыдущий момент времени в расписании</returns>
		public DateTime PrevEvent(DateTime t1)
		{
		}
	}
}